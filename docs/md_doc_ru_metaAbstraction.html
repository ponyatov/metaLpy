<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>metaL/py: [SICP] глава 4 Металингвистическая абстракция</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">metaL/py
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">[SICP] глава 4 Металингвистическая абстракция </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://sarabander.github.io/sicp/html/Chapter-4.xhtml">https://sarabander.github.io/sicp/html/Chapter-4.xhtml</a></p>
<p>Изучая дизайн программ в [SICP], мы видим что опытные программисты управляют сложностью своих проектов с помощью тех же общих методов, которые используются разработчиками всех сложных систем. Они</p>
<ul>
<li>комбинируют примитивные элементы для формирования составных объектов,</li>
<li>абстрагируют составные объекты для формирования строительных блоков более высокого уровня, и</li>
<li>сохраняют модульность, принимая соответствующие крупномасштабные представления о структуре системы.</li>
</ul>
<p>Проиллюстрировав эти методы, мы использовали Лисп как язык для описания процессов и для создания вычислительных объектов данных и процессов для моделирования сложных явлений в реальном мире. Однако по мере того, как мы сталкиваемся со все более сложными проблемами, мы обнаруживаем, что Lisp или <b>любой фиксированный язык программирования недостаточен</b> для наших нужд. Мы должны постоянно обращаться к новым языкам, чтобы более эффективно выражать наши идеи. Определение новых языков &ndash; мощная стратегия контроля сложности инженерного проектирования; мы часто можем улучшить нашу способность справляться со сложной проблемой, применив новый язык, который позволяет нам описывать (и, следовательно, думать о ней) проблему по-другому, используя примитивы, средства комбинирования и средства абстракции, которые особенно важны, и хорошо подходят для решения поставленной задачи. [205]</p>
<p>Программирование всегда тесно связано с множеством языков. Существуют физически низкоуровневые языки, например машинные языки для компьютеров определенной архитектуры. Эти языки предназначены для представления данных и управления в терминах отдельных битов памяти, и примитивных машинных инструкций. Программист, работающий на машинном языке, заинтересован в использовании данного оборудования для создания систем и утилит для максимально эффективной реализации вычислений в ограниченных ресурсах. Языки высокого уровня, выращенные поверх машинного языка, скрывают заботы по поводу представления данных в виде наборов битов в памяти, и представления программ в виде последовательностей примитивных инструкций. В этих языках есть средства комбинирования и абстракции, такие как определение процедур, которые подходят для крупномасштабной организации систем.</p>
<p><em>Металингвистическая абстракция — создание новых языков</em> &ndash; играет важную роль во всех отраслях инженерного проектирования. Это особенно важно для компьютерного программирования, потому что в программировании мы можем не только формулировать новые языки, но и реализовывать эти языки, создавая вычислители. <em>Вычислитель</em> (или <em>интерпретатор</em>) для языка программирования — это процедура, которая при применении к выражению языка выполняет действия, необходимые для оценки (evaluate) этого выражения.</p>
<p>Не будет преувеличением считать это самой фундаментальной идеей программирования:</p>
<blockquote class="doxtable">
<p>вычислитель (evaluator), который определяет значение выражений на некотором языке программирования &ndash; это просто еще одна программа </p>
</blockquote>
<p>Понять это &ndash; значит изменить наше представление о себе как о программистах. Мы начинаем видеть себя разработчиками языков, а не только пользователями языков, созданных другими.</p>
<p>Фактически, мы можем рассматривать почти любую программу как средство вычисления, зананное для некоторого языка. Например, система манипулирования полиномами из 2.5.3 следует правилам полиномиальной арифметики, и реализует их в терминах операций со структурированными списковыми данными. Если мы дополним эту систему процедурами чтения и печати полиномиальных выражений, мы получим ядро <em>специализированного языка</em> для решения задач символьной математики. Симулятор цифровой логики 3.3.4 и распространитель ограничений 3.3.5 явно являются самостоятельными языками сами по себе, каждый со своими примитивами, средствами комбинирования и средствами абстракции. С этой точки зрения, технология взаимодействия с крупномасштабными компьютерными системами сливается с технологией создания новых компьютерных языков, а сама информатика становится не более (и не менее) чем дисциплиной по созданию соответствующих описательных языков.</p>
<p>Теперь мы можем отправиться в путешествие по технологии, с помощью которой языки устанавливаются по отношению к другим языкам. В 4 главе [SICP][ мы будем использовать Lisp в качестве основы, реализуя собственные средства интерпретации как процедуры Lisp. Lisp особенно хорошо подходит для этой задачи из-за его способности представлять и манипулировать символьными выражениями. Мы сделаем первый шаг в понимании того, как реализуются языки, создав вычислитель для самого Lisp. Язык, реализованный нашим вычислителем, будет подмножеством диалекта Scheme Lisp, который мы используем в этой книге. Хотя вычислитель, описанный в этой главе, написан для определенного диалекта Лиспа, он содержит основную структуру интерпретатора для любого языка, ориентированного на выражения, предназначенного для написания программ для последовательной машины. (Фактически, большинство программ работающих с языками, содержат в себе небольшой интерпретатор Lisp.) Оценщик был упрощен для целей иллюстрации и обсуждения, а болшинство функций, необхоимых для практически-применимой Лисп-системы, были опущены. Тем не менее этого простого интерпретатора достаточно для выполнения большинства программ из этой книги. [206]</p>
<p><em>Аналогично, в <b>metaL</b> мы меняем базовую структуру данных для представления программ, и применяем объектно-ориентированный подход вместо функционально-процедурного, но общие принципы реализации системы интерпретации объектного графа как его вычисления в некоторое значение (тоже граф) остается без изменений. Здесь и далее по тексту Lisp нужно читать как Python.</em></p>
<p><em>Отдельно стоит отметить, что, хотя традиционно принято иметь некоторое хранимое представление программ в виде текстовых файлов, наличие синтаксиса для языка вообще говоря не обязательно. Язык полезно определить не на последовательностях символов, представляющих программы, а на данных, то есть рассматривать в качестве непосредственного представления программ некоторые прозвольно выбранные структуры данных. В этом случае мы можем полагаться при работе на все механизмы, уже существующие в языке реализации &ndash; готовый общеизвестный синтаксис и его парсер, отладчик, менеджер памяти, любые существующие библиотеки и готовую инфраструктуру.</em></p>
<p>Важным преимуществом доступности интерпретатора как обычной программы на Лиспе является то, что мы можем реализовать альтернативные правила вычисления, описывая их как модификации программы-вычислителя. Одно из мест, где мы можем использовать эту силу для получения хорошего эффекта, — это получить дополнительный контроль над тем, как вычислительные модели воплощают понятие времени, которое было центральным в обсуждении в главе 3. Здесь мы смягчили некоторые сложности, связанные с состоянием и присваиванием, используя потоки для разделения представления времени в мире от времени в компьютере. Однако наши потоковые программы иногда были громоздкими, потому что они ограничивались аппликативнам порядком вычислений Scheme. В 4.2 мы изменим базовый язык, чтобы обеспечить более элегантный подход, изменив интерпретатор так, чтобы обеспечить <em>вычисление в нормальном порядке</em>.</p>
<p>В разделе 4.3 реализовано более амбициозное лингвистическое изменение, согласно которому выражения имеют много значений, а не одно единственное. На этом языке <em>недетерминированных вычислений</em> естественно выражать процессы, которые генерируют все возможные значения для выражения, а затем отбирают те значения, которые удовлетворяют определённым ограничениям. С точки зрения моделей вычислений и времени, это похоже на разветвление времени на набор «возможных вариантов будущего» и последующий поиск подходящих временных линий. С нашим недетерминированным интерпретатором вычисление нескольких значений и выполнение поиска автоматически обрабатываются внутренним механизмом языка.</p>
<p>В 4.4 мы реализуем язык логического программирования, в котором знания выражаются в терминах отношений, а не в терминах вычислений со входами и выходами. Несмотря на то, что это резко отличает язык от Лиспа или даже от любого обычного языка, мы увидим, что вычислитель для логического программирования разделяет ту же необходимую структуру интерпретатора Лиспа.</p>
<h3>Примечания</h3>
<p>205 Одна и та же идея пронизывает всю инженерию. Например, инженеры-электрики используют много разных языков для описания схем. Два из них &ndash; это язык электрических сетей и язык электрических систем. Сетевой язык выделяет физическое моделирование устройств в терминах дискретных электрических элементов. Примитивные объекты сетевого языка &ndash; это примитивные электрические компоненты, такие как резисторы, конденсаторы, катушки индуктивности и транзисторы, которые характеризуются в терминах физических переменных, называемых напряжением и током. При описании схем на сетевом языке инженер заботится о физических характеристиках проекта. Напротив, примитивными объектами системного языка являются модули обработки сигналов, такие как фильтры и усилители. Имеет значение только функциональное поведение модулей, а сигналы обрабатываются без учета их физической реализации в виде напряжений и токов. Системный язык построен на сетевом языке в том смысле, что элементы систем обработки сигналов построены из электрических сетей. Однако здесь речь идет о крупномасштабной организации электрических устройств для решения данной прикладной задачи; предполагается физическая осуществимость деталей. Этот многоуровневый набор языков является еще одним примером техники стратифицированного проектирования, проиллюстрированной языком изображений 2.2.4.</p>
<p>206 Наиболее важные особенности, которые упускает наш оценщик, &ndash; это механизмы обработки ошибок и поддержки отладки. Для более подробного обсуждения интерпретаторов см. Friedman et al. 1992, в котором рассматривается ряд реализаций языков программирования с использованием последовательности вычислителей, написанных на Scheme.</p>
<p><a href="https://www.notion.so/69a654d80dfe4749842639fac0cfae3b">4.1 Метациркулярный вычислитель</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
